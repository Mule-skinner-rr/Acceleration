 

/* This problem required me to scan in a grid of zeros and/or ones, check if there were any zeros, and print out the coordinates of the zeros, if any.  I also practiced some of the error handling from an example program that was similar to this one.
  My solution stemmed from a single dimension array for storing the coordinates of the sectors without power, if any.  The array allowed the program to capture the coordinates in one function and display them from another.  
  Alternatively, I could have used parallel arrays to store each row and column coordinate.  Using one single dimension array is simpler and occurred to be because of the practice I had at using multiple increment variables while solving the bubble sort program.  
  The following paragraphs explain how the program works and focus on the 'power_ok' and the 'where_off' functions.
  
  The 'power_ok' function shows how the program uses two sets of increment variables, 'i' and 'j', and 'q' and 'r', to store the coordinate numbers where power was out in an array called 'where'.  'i' and 'j' cycle through all of the grid elements.  'q' and 'r' record the increments where a sector is off.
  The 'counter' variable in that function returns zero or any number more than zero back to the 'main' function and on to the 'where_off' function in order to print one of two messages: "Power is on throughout the grid" or "Power is off in sectors...", followed by a list of sector coordinates from the 'coordinate_list' a.k.a. 'where' array.  The 'counter' told the 'where_off' function how many times execute the 'for' loop to print out the coordinate pairs.  Thusly, the 'counter' variable provides two types of information: "on or off?" and a "which one?".

  The 'get_grid' function simply serves to import a table from a file, but I used it to practice error handling.  The program checks that the file opens correctly and that it does not exceed the size of the multi-dimensional 'grid' array.  I chose to check for these errors because they might come up if someone runs this code without setting their working directory correctly or with a file size that exceeds memory allocation.  
  The program uses 'valid_table', the return value from the function, to indicate that the table is valid, or which of the two errors occurred.  I chose the integer one to indicate that the file had scanned correctly because that is a standard value for true.  I used zero and two to indicate an error, so that the 'error_messages' function can use it to determine which error message to print.   
  
  Working on the error handling taught me to think about what errors might actually happen and solve for those problems.  
  Making the program work for different sized files showed me that optimizing can create limits that require more code to solve.  For example, I wanted to add the code for the 'error_messages' function into the 'where_off' function, but couldn't because the 'counter' variable was populated in the 'main' function within an 'if' statement that verified the table was valid, so I couldn't re-call it in an additional call to 'where_off' because it wasn't visible outside of the 'if' sequence's curly braces.  
  I solved this by writing a new function, 'error_messages'.  Doing all of the display statements in one function meant that the program needed to fill all of its parameters in order to call it, even if the section of the function that displayed did not utilize them.  The new function made the program longer, but better organized.

  Overall, this was a fun problem to work on because I got to use return variables for more than one purpose, use double increments to store and display coordinates from a single dimension array and practice error handling and modularity.  */ 
